//     derot is the GUI frontend that controls the field derotator
//     Copyright (C) 2015  C.Y. Tan
//     Contact: cytan299@yahoo.com

//     This file is part of derot

//     derot is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.

//     derot is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.

//     You should have received a copy of the GNU General Public License
//     along with derot.  If not, see <http://www.gnu.org/licenses/>.

// generated by Fast Light User Interface Designer (fluid) version 1.0304

#include "DeRotatorUI.h"

void DeRotatorUI::cb_mainWindow_i(Fl_Double_Window*, void*) {
  exit(0);
}
void DeRotatorUI::cb_mainWindow(Fl_Double_Window* o, void* v) {
  ((DeRotatorUI*)(o->user_data()))->cb_mainWindow_i(o,v);
}

void DeRotatorUI::cb_Send_i(Fl_Button*, void*) {
  using namespace std;

using namespace logging::trivial;
src::severity_logger< severity_level > lg;  

double home_angle;
RequestPacket rq;
switch(derotator_graphics->GetDrawingMode()){
  case DeRotatorGraphics::CAMERA_OUTLINE_MODE:
    home_angle = derotator_graphics->GetHomeAngle(); // deg
    rq._command = CMD_GOTO_THETA;
    rq._fvalue[0] = FA2HA(derotator_graphics->ZOutlineAngle() - home_angle); // deg
#ifdef AAAAA    
    cerr << "Sending theta (HA) = " << rq._fvalue[0] << "\n";
#endif   
    if(SendCommand(&rq) != REPLY_OK){    
      LOG_ERROR << "DeRotatorUI::Send: SendCommand() error";
      return;
    }
    
    // deactive buttons that can cause trouble when inadvertently hit by the user
    Start->deactivate();
    Home->deactivate();
    SetHome->deactivate();
    SetCWLimit->deactivate();
    SetCCWLimit->deactivate();
    
    //Now start a timer to collect angle data from the derotator
    Fl::add_timeout(REPEAT_TIME, timer_cb2, this);
  break;
  
  case DeRotatorGraphics::HOME_MODE:
    rq._command = SETUP_SET_USER_HOME;
    rq._fvalue[0] = FA2HA(atof(deg->value()));
 #ifdef AAAAA
    cerr << "Sending (HA): " << rq._fvalue[0] << "\n";
 #endif   
    if(SendCommand(&rq) != REPLY_OK){     
      LOG_ERROR << "DeRotatorUI::Send: SendCommand() error";
      return;
    } 
    
    LOG_TRACE << "Home Angle: "
          << "deg = " << deg->value() << ", "
          << "steps = " << steps->value(); 
         
    break;
    
  case DeRotatorGraphics::CW_POS_MODE:
    // opposite between frontend and derotator
    rq._command = SETUP_MAX_CCW;
    rq._fvalue[0] = FA2HA(atof(deg->value()));
 #ifdef AAAAA   
    cerr << "Sending (HA): " << rq._fvalue[0] << "\n";
 #endif   
    if(SendCommand(&rq) != REPLY_OK){
      LOG_ERROR << "DeRotatorUI::Send: SendCommand() error";
      return;
    } 

    break;
    
  case DeRotatorGraphics::CCW_POS_MODE:
  // opposite between frontend and derotator
    rq._command = SETUP_MAX_CW;
    rq._fvalue[0] = FA2HA(atof(deg->value()));
 #ifdef AAAAA   
    cerr << "Sending (HA): " << rq._fvalue[0] << "\n";
 #endif   
    if(SendCommand(&rq) != REPLY_OK){    
      LOG_ERROR << "DeRotatorUI::Send: SendCommand() error";
      return;
    } 

    break;
};
}
void DeRotatorUI::cb_Send(Fl_Button* o, void* v) {
  ((DeRotatorUI*)(o->parent()->parent()->user_data()))->cb_Send_i(o,v);
}

void DeRotatorUI::cb_SetHome_i(Fl_Light_Button* o, void*) {
  if(o->value() > 0) { // toggled
  // disable buttons that cannot be used
  SetCWLimit->deactivate();
  SetCCWLimit->deactivate();
  Start->deactivate();
  Stop->deactivate();
  Home->deactivate();
  
  // update the steps and deg input boxes
  char buf[32];
  sprintf(buf, "%4.2f", derotator_graphics->GetHomeAngle());
  deg->value(buf);
  sprintf(buf, "%4d",
          static_cast<int>(derotator_graphics->GetHomeAngle()/MECHANICAL_STEPSIZE));
  steps->value(buf);

  
  derotator_graphics->SetDrawingMode(DeRotatorGraphics::HOME_MODE);
 }
else {
  SetCWLimit->activate();
  SetCCWLimit->activate();
  Start->activate();
  Stop->activate();
  Home->activate();
  
  // query the derotator for the current user home position
  RequestPacket rq;
  rq._command = CMD_GET_USER_HOME_POS;
  ReplyPacket rp;

  if(SendCommand(&rq, &rp) != REPLY_OK){
    using namespace logging::trivial;
    src::severity_logger< severity_level > lg;    
    LOG_ERROR << "DeRotatorUI::SetUserHome: SendCommand() get home pos error";
    derotator_graphics->SetDrawingMode(DeRotatorGraphics::CAMERA_OUTLINE_MODE);
    derotator_graphics->redraw();
    
    // also reset the steps and deg boxes of the camera outline
    char buf[32];
    sprintf(buf, "%4.2f", derotator_graphics->ZOutlineAngle());
    deg->value(buf);
    sprintf(buf, "%4d", static_cast<int>(derotator_graphics->ZOutlineAngle()/MECHANICAL_STEPSIZE));
    steps->value(buf);

    return;
  }
  
  double angle = HS2FA(rp._fvalue[0]); // degrees

  derotator_graphics->SetHomeAngle(angle); // degrees
  derotator_graphics->SetDrawingMode(DeRotatorGraphics::CAMERA_OUTLINE_MODE);
  
  // also reset the steps and deg boxes to that of the camera outline
  char buf[32];
  sprintf(buf, "%4.2f", derotator_graphics->ZOutlineAngle());
  deg->value(buf);
  sprintf(buf, "%4d", static_cast<int>(derotator_graphics->ZOutlineAngle()/MECHANICAL_STEPSIZE));
  steps->value(buf);
}

derotator_graphics->redraw();
}
void DeRotatorUI::cb_SetHome(Fl_Light_Button* o, void* v) {
  ((DeRotatorUI*)(o->parent()->parent()->user_data()))->cb_SetHome_i(o,v);
}

void DeRotatorUI::cb_SetCWLimit_i(Fl_Light_Button* o, DeRotatorUI*) {
  if(o->value() > 0) { // toggled
  // disable buttons that cannot be used
  SetHome->deactivate();
  SetCCWLimit->deactivate();
  Start->deactivate();
  Stop->deactivate();
  Home->deactivate();
  
  // update the steps and deg input boxes
  char buf[32];
  sprintf(buf, "%4.2f", derotator_graphics->GetMaxCWAngle());
  deg->value(buf);
  sprintf(buf, "%4d",
          static_cast<int>(derotator_graphics->GetMaxCWAngle()/MECHANICAL_STEPSIZE));
  steps->value(buf);
  
  derotator_graphics->SetDrawingMode(DeRotatorGraphics::CW_POS_MODE); 

}
else {

  using namespace logging::trivial;;
  src::severity_logger< severity_level > lg;      

  // enable buttons that cannot be used
  SetHome->activate();
  SetCCWLimit->activate();
  Start->activate();
  Stop->activate();
  Home->activate();
  
  // query the derotator for the max cw position
  // note the opposite that CW here is equivalent to CCW
  // of the hardware
  RequestPacket rq;
  rq._command = CMD_GET_MAX_CCW_POS;
  ReplyPacket rp;

  if(SendCommand(&rq, &rp) != REPLY_OK){
    LOG_ERROR << "DeRotatorUI::SetUserHome: SendCommand() get max cw pos error";
    
    derotator_graphics->SetDrawingMode(DeRotatorGraphics::CAMERA_OUTLINE_MODE);
    derotator_graphics->redraw();
    
    // also reset the steps and deg boxes of the camera outline
    char buf[32];
    sprintf(buf, "%4.2f", derotator_graphics->ZOutlineAngle());
    deg->value(buf);
    sprintf(buf, "%4d", static_cast<int>(derotator_graphics->ZOutlineAngle()/MECHANICAL_STEPSIZE));
    steps->value(buf);

    return;
  }
  
  double angle = HS2FA(rp._fvalue[0]); // degrees

  derotator_graphics->SetMaxCWAngle(angle); // degrees
    cerr << "max cw angle (FA) = " << angle << "\n";
    derotator_graphics->SetDrawingMode(DeRotatorGraphics::CAMERA_OUTLINE_MODE);
  
  // also reset the steps and deg boxes of the camera outline
  char buf[32];
  sprintf(buf, "%4.2f", derotator_graphics->ZOutlineAngle());
  deg->value(buf);
  sprintf(buf, "%4d", static_cast<int>(derotator_graphics->ZOutlineAngle()/MECHANICAL_STEPSIZE));
  steps->value(buf);

}

derotator_graphics->redraw();
}
void DeRotatorUI::cb_SetCWLimit(Fl_Light_Button* o, DeRotatorUI* v) {
  ((DeRotatorUI*)(o->parent()->parent()->user_data()))->cb_SetCWLimit_i(o,v);
}

void DeRotatorUI::cb_SetCCWLimit_i(Fl_Light_Button* o, void*) {
  if(o->value() > 0) { // toggled
  // disable buttons that cannot be used
  SetHome->deactivate();
  SetCWLimit->deactivate();
  Start->deactivate();
  Stop->deactivate();
  Home->deactivate();
  
    
  // update the steps and deg input boxes
  char buf[32];
  sprintf(buf, "%4.2f", derotator_graphics->GetMaxCCWAngle());
  deg->value(buf);
  sprintf(buf, "%4d",
          static_cast<int>(derotator_graphics->GetMaxCCWAngle()/MECHANICAL_STEPSIZE));
  steps->value(buf);
  
  derotator_graphics->SetDrawingMode(DeRotatorGraphics::CCW_POS_MODE);

}
else {

  using namespace logging::trivial;
  src::severity_logger< severity_level > lg;
   
  // enable buttons that cannot be used
  SetHome->activate();
  SetCWLimit->activate();
  Start->activate();
  Stop->activate();
  Home->activate();
  
  // query the derotator for the current max ccw position
  // note the opposite that CCW here is equivalent to CW
  // of the hardware
  RequestPacket rq;
  rq._command = CMD_GET_MAX_CW_POS;
  ReplyPacket rp;

  if(SendCommand(&rq, &rp) != REPLY_OK){
    LOG_ERROR << "DeRotatorUI::SetUserHome: SendCommand() get max ccw pos error";
    
    derotator_graphics->SetDrawingMode(DeRotatorGraphics::CAMERA_OUTLINE_MODE);
    derotator_graphics->redraw();
    
    // also reset the steps and deg boxes of the camera outline
    char buf[32];
    sprintf(buf, "%4.2f", derotator_graphics->ZOutlineAngle());
    deg->value(buf);
    sprintf(buf, "%4d", static_cast<int>(derotator_graphics->ZOutlineAngle()/MECHANICAL_STEPSIZE));
    steps->value(buf);

    return;
  }
  
  double angle = HS2FA(rp._fvalue[0]); // degrees

  derotator_graphics->SetMaxCCWAngle(angle); // degrees
      cerr << "max ccw angle (FA) = " << angle << "\n";
      
  derotator_graphics->SetDrawingMode(DeRotatorGraphics::CAMERA_OUTLINE_MODE);
  
  // also reset the steps and deg boxes to that of the camera outline
  char buf[32];
  sprintf(buf, "%4.2f", derotator_graphics->ZOutlineAngle());
  deg->value(buf);
  sprintf(buf, "%4d", static_cast<int>(derotator_graphics->ZOutlineAngle()/MECHANICAL_STEPSIZE));
  steps->value(buf);


}

derotator_graphics->redraw();
}
void DeRotatorUI::cb_SetCCWLimit(Fl_Light_Button* o, void* v) {
  ((DeRotatorUI*)(o->parent()->parent()->user_data()))->cb_SetCCWLimit_i(o,v);
}

void DeRotatorUI::cb_steps_i(Fl_Int_Input* o, void*) {
  double home_angle = derotator_graphics->GetHomeAngle();
double angle;
switch(derotator_graphics->GetDrawingMode()){
  case DeRotatorGraphics::CAMERA_OUTLINE_MODE:
    angle = atof(((Fl_Int_Input*)o)->value())*MECHANICAL_STEPSIZE;
    derotator_graphics->ZOutlineAngle(angle + home_angle);
  break;
  
  case DeRotatorGraphics::HOME_MODE:
   // update the tmp angle in DeRotatoGraphics, only Send can update the permanent angles
   derotator_graphics->SetTmpHomeAngle(atof(((Fl_Int_Input*)o)->value())*MECHANICAL_STEPSIZE);
  break;
  
  case DeRotatorGraphics::CW_POS_MODE:
   derotator_graphics->SetTmpCWAngle(atof(((Fl_Int_Input*)o)->value())*MECHANICAL_STEPSIZE);
  break;
  
  case DeRotatorGraphics::CCW_POS_MODE:
   derotator_graphics->SetTmpCCWAngle(atof(((Fl_Int_Input*)o)->value())*MECHANICAL_STEPSIZE);
  break;
}

derotator_graphics->redraw();

// and then the deg box
char buf[32];
sprintf(buf, "%4.2f",
	atof(((Fl_Int_Input*)o)->value())*MECHANICAL_STEPSIZE);
deg->value(buf);
}
void DeRotatorUI::cb_steps(Fl_Int_Input* o, void* v) {
  ((DeRotatorUI*)(o->parent()->parent()->user_data()))->cb_steps_i(o,v);
}

void DeRotatorUI::cb_deg_i(Fl_Float_Input* o, void*) {
  double home_angle = derotator_graphics->GetHomeAngle();
double angle;
switch(derotator_graphics->GetDrawingMode()){
  case DeRotatorGraphics::CAMERA_OUTLINE_MODE:
    angle = atof(((Fl_Float_Input*)o)->value());
    derotator_graphics->ZOutlineAngle(angle + home_angle);
  break;
  
  case DeRotatorGraphics::HOME_MODE:
   // update the tmp angle in DeRotatoGraphics, only Send can update the permanent angles
   derotator_graphics->SetTmpHomeAngle(atof(((Fl_Float_Input*)o)->value()));
  break;
  
  case DeRotatorGraphics::CW_POS_MODE:
   derotator_graphics->SetTmpCWAngle(atof(((Fl_Float_Input*)o)->value()));
  break;
  
  case DeRotatorGraphics::CCW_POS_MODE:
   derotator_graphics->SetTmpCCWAngle(atof(((Fl_Float_Input*)o)->value()));
  break;
}

derotator_graphics->redraw();
    
char buf[32];
// and then the steps box
sprintf(buf, "%4d",
	static_cast<int>(atof(((Fl_Float_Input*)o)->value())/MECHANICAL_STEPSIZE));
steps->value(buf);
}
void DeRotatorUI::cb_deg(Fl_Float_Input* o, void* v) {
  ((DeRotatorUI*)(o->parent()->parent()->user_data()))->cb_deg_i(o,v);
}

void DeRotatorUI::cb_Start_i(Fl_Button*, void*) {
  using namespace std;
using namespace logging::trivial;
src::severity_logger< severity_level > lg;   

RequestPacket rq;

/* get telescope position */
rq._command = CMD_GET_ALTAZ_ZETA;
ReplyPacket rp;

if(SendCommand(&rq, &rp) == REPLY_OK){
  LOG_TRACE << "Start: telescope at ("
            << rp._fvalue[0] << ", "
            << rp._fvalue[1]  << ")";
}
else {
  LOG_ERROR << "DeRotatorUI::Start: SendCommand() failed";
  return;
}

/* Now we can really start ...*/
rq._command = DEROTATOR_START;

if(SendCommand(&rq) != REPLY_OK){   
  LOG_ERROR << "DeRotatorUI::Start: SendCommand() failed";
  return;
}

// deactivate buttons that could cause problems when pressed during this time
Start->deactivate();
Home->deactivate();

Send->deactivate();
SetHome->deactivate();
SetCWLimit->deactivate();
SetCCWLimit->deactivate();

// write out the time where derotation started plus camera position
LOG_TRACE << "Start: "
          << "deg = " << deg->value() << ", "
          << "steps = " << steps->value();

                   
//Now start a timer to collect angle data from the derotator
Fl::add_timeout(REPEAT_TIME, timer_cb, this);
}
void DeRotatorUI::cb_Start(Fl_Button* o, void* v) {
  ((DeRotatorUI*)(o->parent()->parent()->user_data()))->cb_Start_i(o,v);
}

void DeRotatorUI::cb_Stop_i(Fl_Button*, void*) {
  using namespace std;
using namespace logging::trivial;
src::severity_logger< severity_level > lg;
  
// remove all timer callbacks for updates
Fl::remove_timeout(timer_cb, this);
Fl::remove_timeout(timer_cb1, this);
Fl::remove_timeout(timer_cb2, this);


RequestPacket rq;
rq._command = DEROTATOR_STOP;

if(SendCommand(&rq) != REPLY_OK){    
  LOG_ERROR << "DeRotatorUI::Stop: SendCommand() failed";
  return;
}

LOG_TRACE << "Stop: " 
          << "deg = " << deg->value() << " "
          << "steps = " << steps->value();
          
/* get telescope position */
rq._command = CMD_GET_ALTAZ_ZETA;
ReplyPacket rp;

if(SendCommand(&rq, &rp) == REPLY_OK){
  LOG_TRACE << "Stop: telescope at ("
            << rp._fvalue[0] << ", "
            << rp._fvalue[1]  << ")";


}
else {
  LOG_ERROR << "DeRotatorUI::Stop: SendCommand() failed";
  return;
}



// reactivate buttons that were previously deactivated
Start->activate();
Home->activate();

Send->activate();
SetHome->activate();
SetCWLimit->activate();
SetCCWLimit->activate();
}
void DeRotatorUI::cb_Stop(Fl_Button* o, void* v) {
  ((DeRotatorUI*)(o->parent()->parent()->user_data()))->cb_Stop_i(o,v);
}

void DeRotatorUI::cb_Home_i(Fl_Button*, void*) {
  using namespace std;
// stop the timer callback for updates
Fl::remove_timeout(timer_cb1, this);

RequestPacket rq;
rq._command = DEROTATOR_GOTO_USER_HOME;

if(SendCommand(&rq) != REPLY_OK){
  using namespace logging::trivial;
  src::severity_logger< severity_level > lg;      
  LOG_ERROR << "DeRotatorUI::Home: SendCommand() failed";
  return;
}


// deactivate buttons that could cause problems when pressed during this time
Send->deactivate();
SetHome->deactivate();
SetCWLimit->deactivate();
SetCCWLimit->deactivate();

Start->deactivate();

//Now start a timer to collect angle data from the derotator
Fl::add_timeout(REPEAT_TIME, timer_cb1, this);
}
void DeRotatorUI::cb_Home(Fl_Button* o, void* v) {
  ((DeRotatorUI*)(o->parent()->parent()->user_data()))->cb_Home_i(o,v);
}

void DeRotatorUI::cb_OpenConfiguration_i(Fl_Menu_*, void*) {
  using namespace std;
using namespace boost::filesystem;

string filename;

Fl_Native_File_Chooser fchooser;

fchooser.title("Open Configuration");
fchooser.type(Fl_Native_File_Chooser::BROWSE_FILE);
fchooser.filter("*.prefs");
fchooser.preset_file("derot.prefs");
fchooser.directory(_derotator_config->GetUserConfigPath());

using namespace logging::trivial;
src::severity_logger< severity_level > lg;
 
switch(fchooser.show()){
  case -1: 
    LOG_ERROR << "OpenConfiguration: error: "
	      << fchooser.errmsg();
    break;
    
  case 1: 
    LOG_INFO << "Canceled";
    break;
    
  default:
    if(fchooser.filename()){
      filename = fchooser.filename();
    }  
}

if(filename.size() > 0){
   _derotator_config->Load(filename.c_str());
  
  return;
};
}
void DeRotatorUI::cb_OpenConfiguration(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_OpenConfiguration_i(o,v);
}

void DeRotatorUI::cb_SaveConfiguration_i(Fl_Menu_* o, void*) {
  if(_derotator_config->IsGotFilename()){
    _derotator_config->Save();
}
else {
    SaveConfigurationAs->do_callback(o);
};
}
void DeRotatorUI::cb_SaveConfiguration(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_SaveConfiguration_i(o,v);
}

void DeRotatorUI::cb_SaveConfigurationAs_i(Fl_Menu_*, void*) {
  using namespace std;
using namespace boost::filesystem;


string filename;

Fl_Native_File_Chooser fchooser;

fchooser.title("Save Configuration As");
fchooser.type(Fl_Native_File_Chooser::BROWSE_SAVE_FILE);
fchooser.filter("*.prefs");
fchooser.directory(_derotator_config->GetUserConfigPath());
fchooser.options(Fl_Native_File_Chooser::NEW_FOLDER | 
                 Fl_Native_File_Chooser::SAVEAS_CONFIRM | 
                 Fl_Native_File_Chooser::USE_FILTER_EXT); 
fchooser.preset_file("derot.prefs");

using namespace logging::trivial;
src::severity_logger< severity_level > lg;    

switch(fchooser.show()){
  case -1: 
    LOG_ERROR << "SaveConfigurationAs: error: "
	      << fchooser.errmsg();
    break;
    
  case 1: 
    LOG_INFO << "Canceled";
    break;
    
  default:
    if(fchooser.filename()){
      filename = fchooser.filename();
    }  
}

if(filename.size() > 0){
  _derotator_config->Save(filename.c_str());
    
  return;
};
}
void DeRotatorUI::cb_SaveConfigurationAs(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_SaveConfigurationAs_i(o,v);
}

void DeRotatorUI::cb_QuitAndSaveConfig_i(Fl_Menu_*, void*) {
  _derotator_config->Save();

using namespace logging::trivial;
src::severity_logger< severity_level > lg;

LOG_INFO << "Saved global log";

exit(0);
}
void DeRotatorUI::cb_QuitAndSaveConfig(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_QuitAndSaveConfig_i(o,v);
}

void DeRotatorUI::cb_Quit_i(Fl_Menu_*, void*) {
  exit(0);
}
void DeRotatorUI::cb_Quit(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_Quit_i(o,v);
}

void DeRotatorUI::cb_WifiIPAddress_i(Fl_Menu_*, void*) {
  WifiIPPopup->position(mainWindow->x_root()+50, 
                      mainWindow->y_root()+200);
WifiIPPopup->show();
}
void DeRotatorUI::cb_WifiIPAddress(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_WifiIPAddress_i(o,v);
}

void DeRotatorUI::cb_SerialDevPort_i(Fl_Menu_*, void*) {
  SerialDevPopup->position(mainWindow->x_root()+50,
                         mainWindow->y_root()+200);
SerialDevPopup->show();
}
void DeRotatorUI::cb_SerialDevPort(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_SerialDevPort_i(o,v);
}

void DeRotatorUI::cb_QueryHardware_i(Fl_Menu_*, void*) {
  // get the angle of the derotator clockwise state
using namespace std;

RequestPacket rq;
rq._command = CMD_QUERY_STATE;

if(_serial_client){
  if(_serial_client->Send(&rq) != 0){
    throw string("Send request failed");
  }  
}

if(_tcp_client){
  if(_tcp_client->Send(&rq) != 0){
    throw string("Send request failed");
  }  
}


StatusPacket sp;
if(_serial_client){
  if(_serial_client->Receive(&sp) !=0){
    throw string("Did not receive reply packet");
  }
}

if(_tcp_client){
  if(_tcp_client->Receive(&sp) !=0){
    throw string("Did not receive reply packet");
  }
}   

if(sp._reply >= 0){

  sp._is_clockwise_correction > 0? IsClockWise->set(): IsClockWise->clear();
  
  if(sp._is_enable_limits > 0){
    IsLimitsEnabled->set();
    derotator_graphics->EnableLimits();
  }
  else {
    IsLimitsEnabled->clear();
    derotator_graphics->DisableLimits();
  }
  
  double home_angle = HS2FA(sp._home_pos);
  double angle = HA2FA(sp._angle) + home_angle;// get the absolute angle of the camera
  
  derotator_graphics->ZCameraAngle(angle);
  derotator_graphics->ZOutlineAngle(angle);
  derotator_graphics->ZAngle(sp._accumulated_angle);
  
  derotator_graphics->SetHomeAngle(home_angle);
  
  // note that I have to reverse the max cw angle between
  // the derotator and the frontend because CW and CCW is
  // defined in the opposite direction.
  derotator_graphics->SetMaxCWAngle(HS2FA(sp._max_ccw));
  derotator_graphics->SetMaxCCWAngle(HS2FA(sp._max_cw));

   
  derotator_graphics->redraw();
  
  char buf[32];
  sprintf(buf, "%4.2f", HA2FA(sp._angle));
  deg->value(buf);
  
  sprintf(buf, "%4d", static_cast<int>(HA2FS(sp._angle)));
  steps->value(buf);
  
  // update the ssid and security type
  WLANSSID->value(sp._WLAN_ssid);
  WLANSecurity->value(sp._WLAN_security);

  using namespace logging::trivial;
  src::severity_logger< severity_level > lg;      
  
  LOG_INFO << "is clockwise direction " << sp._is_clockwise_correction;
  LOG_INFO << "home pos (FS)  = " << sp._home_pos;
  LOG_INFO << "max cw (FS) = " << sp._max_cw; 
  LOG_INFO << "max ccw (FS) = " << sp._max_ccw;
  LOG_INFO << "is enable limits = " << sp._is_enable_limits;
  LOG_INFO << "angle (FA) = " << sp._angle;
  LOG_INFO << "accumulated angle = " << sp._accumulated_angle;
  LOG_INFO << "WLAN ssid = " << sp._WLAN_ssid;
  LOG_INFO << "WLAN security = " << sp._WLAN_security;
  
  LOG_INFO << "Setting Hall home " << -HS2FA(sp._home_pos);
  derotator_graphics->SetHallAngle(-HS2FA(sp._home_pos));
  derotator_graphics->SetHomeAngle(HS2FA(sp._home_pos));
  
  // check that if the derotator is already doing derotation
  if(sp._reply == REPLY_IS_DEROTATING){
        
    /* get telescope position */
    rq._command = CMD_GET_ALTAZ_ZETA;
    ReplyPacket rp;

    if(SendCommand(&rq, &rp) == REPLY_OK){
      LOG_TRACE << "Start: telescope at ("
                << rp._fvalue[0] << ", "
                << rp._fvalue[1]  << ")";
    }
    else {
      LOG_ERROR << "DeRotatorUI::QueryHardware: SendCommand() failed";
      return;
    }
    
    // deactivate buttons that could cause problems when pressed during this time
    Start->deactivate();
    Home->deactivate();

    Send->deactivate();
    SetHome->deactivate();
    SetCWLimit->deactivate();
    SetCCWLimit->deactivate();
    
    //Now start a timer to collect angle data from the derotator
    Fl::add_timeout(REPEAT_TIME, timer_cb, this);
     
  }

}
else {
  using namespace logging::trivial;
  src::severity_logger< severity_level > lg;          
// throw string("Reply is not ok");
  LOG_ERROR << "Reply is not ok";
  LOG_ERROR << "Got reply = " << sp._reply;
};
}
void DeRotatorUI::cb_QueryHardware(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_QueryHardware_i(o,v);
}

void DeRotatorUI::cb_SetHallHome_i(Fl_Menu_*, void*) {
  SetHallHomePopup->position(mainWindow->x_root()+50, 
                           mainWindow->y_root()+200);
                      
char buf[32];
sprintf(buf, "%4.2f", derotator_graphics->GetHallAngle());
HallAngleInput->value(buf);
                         
SetHallHomePopup->show();
}
void DeRotatorUI::cb_SetHallHome(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_SetHallHome_i(o,v);
}

void DeRotatorUI::cb_SetDisplayCameraAngle_i(Fl_Menu_*, void*) {
  SetDisplayCameraAnglePopup->position(mainWindow->x_root()+50, 
                           mainWindow->y_root()+200);
                      
char buf[32];
sprintf(buf, "%4.2f", derotator_graphics->GetDisplayCameraAngle());
DisplayCameraAngleInput->value(buf);
                         
SetDisplayCameraAnglePopup->show();
}
void DeRotatorUI::cb_SetDisplayCameraAngle(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_SetDisplayCameraAngle_i(o,v);
}

void DeRotatorUI::cb_IsLimitsEnabled_i(Fl_Menu_*, void*) {
  // enable or disable the derotator limits 
using namespace std;

RequestPacket rq;
rq._command = SETUP_ENABLE_LIMITS;
// if "are cw and ccw limits enabled?" button is checked if it is enabled
rq._ivalue = IsLimitsEnabled->value() != 0? 1:0; 

if(SendCommand(&rq) != REPLY_OK){
  using namespace logging::trivial;
  src::severity_logger< severity_level > lg;      
  LOG_ERROR << "DeRotatorUI::IsLimitsEnabled: SendCommand() failed";
  return;
}

IsLimitsEnabled->value() != 0? 
  derotator_graphics->EnableLimits(): derotator_graphics->DisableLimits();
  
derotator_graphics->redraw();
}
void DeRotatorUI::cb_IsLimitsEnabled(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_IsLimitsEnabled_i(o,v);
}

void DeRotatorUI::cb_IsClockWise_i(Fl_Menu_*, void*) {
  // set the derotator clockwise state
using namespace std;

RequestPacket rq;
rq._command = SETUP_IS_CLOCKWISE;
// if "is correction clockwise?" button is checked it is clockwise
rq._ivalue = IsClockWise->value() != 0? 1:0; 

if(SendCommand(&rq) != REPLY_OK){
  using namespace logging::trivial;
  src::severity_logger< severity_level > lg;      
  LOG_ERROR << "DeRotatorUI::IsClockWise: SendCommand() failed";
  return;
};
}
void DeRotatorUI::cb_IsClockWise(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_IsClockWise_i(o,v);
}

void DeRotatorUI::cb_SetHardwareWLAN_i(Fl_Menu_*, void*) {
  HardwareWLANPopup->position(mainWindow->x_root()+5, 
                            mainWindow->y_root()+200);

HardwareWLANPopup->show();
}
void DeRotatorUI::cb_SetHardwareWLAN(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_SetHardwareWLAN_i(o,v);
}

void DeRotatorUI::cb_SaveHardwareSetup_i(Fl_Menu_*, void*) {
  using namespace std;

RequestPacket rq;
rq._command = SETUP_SAVE_SETTINGS;

int reply;
if((reply = SendCommand(&rq))!= REPLY_OK){
  // throw string("Reply is not ok");
  using namespace logging::trivial;
  src::severity_logger< severity_level > lg;      
  LOG_ERROR << "SaveHardwareSetup(): SendCommand() reply is not ok";
  LOG_ERROR << "Got reply = " << reply;
};
}
void DeRotatorUI::cb_SaveHardwareSetup(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_SaveHardwareSetup_i(o,v);
}

void DeRotatorUI::cb_LoadHardwareSetup_i(Fl_Menu_*, void*) {
  using namespace std;

RequestPacket rq;
rq._command = SETUP_LOAD_SETTINGS;

int reply;
if((reply = SendCommand(&rq))!= REPLY_OK){
  // throw string("Reply is not ok");
  using namespace logging::trivial;
  src::severity_logger< severity_level > lg;      
  LOG_ERROR << "SaveHardwareSetup(): SendCommand() reply is not ok";
  LOG_ERROR << "Got reply = " << reply;
};
}
void DeRotatorUI::cb_LoadHardwareSetup(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_LoadHardwareSetup_i(o,v);
}

void DeRotatorUI::cb_LoadDefaultHardwareSetup_i(Fl_Menu_*, void*) {
  using namespace std;

RequestPacket rq;
rq._command = SETUP_DEF_SETTINGS;

int reply;
if((reply = SendCommand(&rq))!= REPLY_OK){
  // throw string("Reply is not ok");
  using namespace logging::trivial;
  src::severity_logger< severity_level > lg;      
  LOG_ERROR << "SaveHardwareSetup(): SendCommand() reply is not ok";
  LOG_ERROR << "Got reply = " << reply;
};
}
void DeRotatorUI::cb_LoadDefaultHardwareSetup(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_LoadDefaultHardwareSetup_i(o,v);
}

void DeRotatorUI::cb_IntroducingFieldDeRotator_i(Fl_Menu_*, void*) {
  _introduction->load((_help_dir + 
"introduction/introduction.html").c_str());
_introduction->show();
}
void DeRotatorUI::cb_IntroducingFieldDeRotator(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_IntroducingFieldDeRotator_i(o,v);
}

void DeRotatorUI::cb_UserInterfaceHelp_i(Fl_Menu_*, void*) {
  _interface_help->load((_help_dir+
  "help_interface/help_interface.html").c_str());
_interface_help->show();
}
void DeRotatorUI::cb_UserInterfaceHelp(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_UserInterfaceHelp_i(o,v);
}

void DeRotatorUI::cb_ControllerHelp_i(Fl_Menu_*, void*) {
  _controller_help->load((_help_dir+
"help_controller/help_controller.html").c_str());
_controller_help->show();
}
void DeRotatorUI::cb_ControllerHelp(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_ControllerHelp_i(o,v);
}

void DeRotatorUI::cb_About_i(Fl_Menu_*, void*) {
  using namespace std;

Version->position(mainWindow->x_root()+70, mainWindow->y_root()+200);
char buf[128];
sprintf(buf, "Field DeRotator\n\
Copyright (C) 2015 C.Y. Tan\n\
Released under GPL v3\n\
Version %s", PROJECT_VERSION);
VersionLabel->copy_label(buf);
Version->show();
}
void DeRotatorUI::cb_About(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_About_i(o,v);
}

void DeRotatorUI::cb_SerialStatus_i(Fl_Menu_*, void*) {
  if(_serial_client == NULL){
  SerialDevPopup->position(mainWindow->x_root()+50, 
                           mainWindow->y_root()+200);
  SerialDevPopup->show();
}
else {
  // close the serial port
  delete _serial_client;
  _serial_client = NULL;
  // turn off button
  SerialStatus->clear();
  MenuBar->redraw(); // update the serial radio button
};
}
void DeRotatorUI::cb_SerialStatus(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_SerialStatus_i(o,v);
}

void DeRotatorUI::cb_WifiStatus_i(Fl_Menu_*, void*) {
  if(_tcp_client == NULL){
  WifiIPPopup->position(mainWindow->x_root()+50, 
                      mainWindow->y_root()+200);

  WifiIPPopup->show();
}
else {
  // close the tcp port
  delete _tcp_client;
  _tcp_client = NULL;
  WifiStatus->clear();
  MenuBar->redraw(); // update the wifi radio button
};
}
void DeRotatorUI::cb_WifiStatus(Fl_Menu_* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_WifiStatus_i(o,v);
}

Fl_Menu_Item DeRotatorUI::menu_MenuBar[] = {
 {"&File", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Open Configuration ...", 0,  (Fl_Callback*)DeRotatorUI::cb_OpenConfiguration, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Save Configuration", 0,  (Fl_Callback*)DeRotatorUI::cb_SaveConfiguration, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Save Configuration As ...", 0,  (Fl_Callback*)DeRotatorUI::cb_SaveConfigurationAs, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Quit and save config", 0,  (Fl_Callback*)DeRotatorUI::cb_QuitAndSaveConfig, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Quit", 0,  (Fl_Callback*)DeRotatorUI::cb_Quit, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Connect", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Wifi IP address ...", 0,  (Fl_Callback*)DeRotatorUI::cb_WifiIPAddress, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Serial port ...", 0,  (Fl_Callback*)DeRotatorUI::cb_SerialDevPort, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Hardware &Setup", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Query hardware", 0,  (Fl_Callback*)DeRotatorUI::cb_QueryHardware, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Set Hall home ...", 0,  (Fl_Callback*)DeRotatorUI::cb_SetHallHome, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Set display camera angle ...", 0,  (Fl_Callback*)DeRotatorUI::cb_SetDisplayCameraAngle, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Are limits enabled?", 0,  (Fl_Callback*)DeRotatorUI::cb_IsLimitsEnabled, 0, 2, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Is correction clockwise?", 0,  (Fl_Callback*)DeRotatorUI::cb_IsClockWise, 0, 130, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Setup hardware WLAN ...", 0,  (Fl_Callback*)DeRotatorUI::cb_SetHardwareWLAN, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Save hardware setup to EEPROM", 0,  (Fl_Callback*)DeRotatorUI::cb_SaveHardwareSetup, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Load hardware setup from EEPROM", 0,  (Fl_Callback*)DeRotatorUI::cb_LoadHardwareSetup, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Load default hardware settings", 0,  (Fl_Callback*)DeRotatorUI::cb_LoadDefaultHardwareSetup, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Help", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Introducing the Field DeRotator ...", 0,  (Fl_Callback*)DeRotatorUI::cb_IntroducingFieldDeRotator, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"User Interface Help ...", 0,  (Fl_Callback*)DeRotatorUI::cb_UserInterfaceHelp, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Controller help ...", 0,  (Fl_Callback*)DeRotatorUI::cb_ControllerHelp, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"About ...", 0,  (Fl_Callback*)DeRotatorUI::cb_About, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"serial", 0,  (Fl_Callback*)DeRotatorUI::cb_SerialStatus, 0, 8, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"wifi", 0,  (Fl_Callback*)DeRotatorUI::cb_WifiStatus, 0, 8, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};
Fl_Menu_Item* DeRotatorUI::OpenConfiguration = DeRotatorUI::menu_MenuBar + 1;
Fl_Menu_Item* DeRotatorUI::SaveConfiguration = DeRotatorUI::menu_MenuBar + 2;
Fl_Menu_Item* DeRotatorUI::SaveConfigurationAs = DeRotatorUI::menu_MenuBar + 3;
Fl_Menu_Item* DeRotatorUI::QuitAndSaveConfig = DeRotatorUI::menu_MenuBar + 4;
Fl_Menu_Item* DeRotatorUI::Quit = DeRotatorUI::menu_MenuBar + 5;
Fl_Menu_Item* DeRotatorUI::WifiIPAddress = DeRotatorUI::menu_MenuBar + 8;
Fl_Menu_Item* DeRotatorUI::SerialDevPort = DeRotatorUI::menu_MenuBar + 9;
Fl_Menu_Item* DeRotatorUI::QueryHardware = DeRotatorUI::menu_MenuBar + 12;
Fl_Menu_Item* DeRotatorUI::SetHallHome = DeRotatorUI::menu_MenuBar + 13;
Fl_Menu_Item* DeRotatorUI::SetDisplayCameraAngle = DeRotatorUI::menu_MenuBar + 14;
Fl_Menu_Item* DeRotatorUI::IsLimitsEnabled = DeRotatorUI::menu_MenuBar + 15;
Fl_Menu_Item* DeRotatorUI::IsClockWise = DeRotatorUI::menu_MenuBar + 16;
Fl_Menu_Item* DeRotatorUI::SetHardwareWLAN = DeRotatorUI::menu_MenuBar + 17;
Fl_Menu_Item* DeRotatorUI::SaveHardwareSetup = DeRotatorUI::menu_MenuBar + 18;
Fl_Menu_Item* DeRotatorUI::LoadHardwareSetup = DeRotatorUI::menu_MenuBar + 19;
Fl_Menu_Item* DeRotatorUI::LoadDefaultHardwareSetup = DeRotatorUI::menu_MenuBar + 20;
Fl_Menu_Item* DeRotatorUI::IntroducingFieldDeRotator = DeRotatorUI::menu_MenuBar + 23;
Fl_Menu_Item* DeRotatorUI::UserInterfaceHelp = DeRotatorUI::menu_MenuBar + 24;
Fl_Menu_Item* DeRotatorUI::ControllerHelp = DeRotatorUI::menu_MenuBar + 25;
Fl_Menu_Item* DeRotatorUI::About = DeRotatorUI::menu_MenuBar + 26;
Fl_Menu_Item* DeRotatorUI::SerialStatus = DeRotatorUI::menu_MenuBar + 28;
Fl_Menu_Item* DeRotatorUI::WifiStatus = DeRotatorUI::menu_MenuBar + 29;

void DeRotatorUI::cb_OK_i(Fl_Button* o, void*) {
  using namespace std;

if(_tcp_client == NULL){
  using namespace logging::trivial;
  src::severity_logger< severity_level > lg;    
  LOG_INFO << "address = " << IPAddress->value();
  try{
    _tcp_client = new TCPClient(IPAddress->value(), 5001);
  }
  catch(string& s){
    LOG_ERROR << "Cannot connect to WIFI " << s << "\n";
    WifiIPPopup->hide();
    return;
  }
   
  LOG_INFO << "WIFI Connected!";
  // get the current hardware status of the derotator
  LOG_INFO << "querying hardware";
  QueryHardware->do_callback(o); 
  
  // set the wifi toggle button
  WifiStatus->set();
  // unset the serial radio button
  SerialStatus->clear();
   
  // disconnect Wifi if connected and untoggle the wifi button
  if(_serial_client){
    delete _serial_client;
    _serial_client = NULL;
    SerialStatus->clear();
  }
  
  MenuBar->redraw(); // update radio button status

}

WifiIPPopup->hide();
}
void DeRotatorUI::cb_OK(Fl_Button* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_OK_i(o,v);
}

void DeRotatorUI::cb_Cancel_i(Fl_Button*, void*) {
  WifiIPPopup->hide();

if(_tcp_client == NULL){
 // turn off button
  WifiStatus->clear();
  MenuBar->redraw(); // update the serial radio button
};
}
void DeRotatorUI::cb_Cancel(Fl_Button* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_Cancel_i(o,v);
}

void DeRotatorUI::cb_OK1_i(Fl_Button* o, void*) {
  using namespace std;

using namespace logging::trivial;
src::severity_logger< severity_level > lg;
 
if(_serial_client == NULL){
  _serial_client = new SerialClient();
  if(_serial_client->Connect(SerialDevice->value()) != 0){
    LOG_ERROR << "Failed to connect to serial port";
    return; 
  };
  
  // unset the wifi radio button
  WifiStatus->clear();
  // set the serial radio button
  SerialStatus->set();
  
 #ifdef AAAAA
   // get the current hardware status of the derotator
  QueryHardware->do_callback(o);  
#endif
  
  // disconnect Wifi if connected and untoggle the wifi button
  if(_tcp_client){
    delete _tcp_client;
    _tcp_client = NULL;
    WifiStatus->clear();
  }
  
  MenuBar->redraw(); //update the rado buttons
  
 LOG_INFO << "Serial Connected!";
}

SerialDevPopup->hide();
}
void DeRotatorUI::cb_OK1(Fl_Button* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_OK1_i(o,v);
}

void DeRotatorUI::cb_Cancel1_i(Fl_Button*, void*) {
  SerialDevPopup->hide();

if(_serial_client == NULL){
 // turn off button
  SerialStatus->clear();
  MenuBar->redraw(); // update the serial radio button
};
}
void DeRotatorUI::cb_Cancel1(Fl_Button* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_Cancel1_i(o,v);
}

Fl_Menu_Item DeRotatorUI::menu_WLANSecurity[] = {
 {"Unsecure", 0,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"WEP", 0,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"WPA", 0,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"WPA2", 0,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void DeRotatorUI::cb_Send1_i(Fl_Button*, void*) {
  using namespace std;

using namespace logging::trivial;
src::severity_logger< severity_level > lg;        	  
 LOG_INFO << "WLAN ssid = " << WLANSSID->value();
 LOG_INFO << "WLAN password = " << WLANPassword->value();
 LOG_INFO << "WLAN security = " << WLANSecurity->value();

RequestPacket rq;

rq._command = CMD_SET_WLAN_SSID;
strcpy(rq._buf, WLANSSID->value());
rq._buf[strlen(WLANSSID->value())] = '\0';

if(SendCommand(&rq) != REPLY_OK){
  LOG_INFO << "DeRotatorUI::Send via serial: SendCommand(): "
	   << " cannot send WLANSSID "
	   <<  WLANSSID->value();
  return;
}

rq._command = CMD_SET_WLAN_PASS;
strcpy(rq._buf, WLANPassword->value());
rq._buf[strlen(WLANPassword->value())] = '\0';

if(SendCommand(&rq) != REPLY_OK){
  LOG_INFO << "DeRotatorUI::Send via serial: SendCommand(): "
	   << " cannot send WLAN password";
  return;
}

rq._command = CMD_SET_WLAN_SECURITY;
rq._ivalue = WLANSecurity->value();
if(SendCommand(&rq) != REPLY_OK){
  LOG_INFO << "DeRotatorUI::Send via serial: SendCommand(): "
	   << " cannot send WLAN security = "
	   << WLANSecurity->value();
  return;
}


HardwareWLANPopup->hide();
}
void DeRotatorUI::cb_Send1(Fl_Button* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_Send1_i(o,v);
}

void DeRotatorUI::cb_Cancel2_i(Fl_Button*, void*) {
  HardwareWLANPopup->hide();
}
void DeRotatorUI::cb_Cancel2(Fl_Button* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_Cancel2_i(o,v);
}

void DeRotatorUI::cb_OK2_i(Fl_Button* o, void*) {
  ConnectWithPopup->hide();
//only one of the following can be active because they
// are radio buttons from the same group
if(SerialPortSelected->value()){
  SerialStatus->set();
  WifiStatus->clear();
  SerialStatus->do_callback(o);
  return;
}

if(WifiSelected->value()){
  SerialStatus->clear();
  WifiStatus->set();
  WifiStatus->do_callback(o);  
  return;
};
}
void DeRotatorUI::cb_OK2(Fl_Button* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_OK2_i(o,v);
}

void DeRotatorUI::cb_HallAngleInput_i(Fl_Float_Input*, void*) {
  derotator_graphics->SetHallAngle(atof(HallAngleInput->value()));

SetHallHomePopup->hide();
derotator_graphics->redraw();
}
void DeRotatorUI::cb_HallAngleInput(Fl_Float_Input* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_HallAngleInput_i(o,v);
}

void DeRotatorUI::cb_OK3_i(Fl_Button*, void*) {
  derotator_graphics->SetHallAngle(atof(HallAngleInput->value()));

SetHallHomePopup->hide();
derotator_graphics->redraw();
}
void DeRotatorUI::cb_OK3(Fl_Button* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_OK3_i(o,v);
}

void DeRotatorUI::cb_Cancel3_i(Fl_Button*, void*) {
  SetHallHomePopup->hide();
}
void DeRotatorUI::cb_Cancel3(Fl_Button* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_Cancel3_i(o,v);
}

void DeRotatorUI::cb_DisplayCameraAngleInput_i(Fl_Float_Input*, void*) {
  derotator_graphics->SetDisplayCameraAngle(atof(DisplayCameraAngleInput->value()));

SetDisplayCameraAnglePopup->hide();
derotator_graphics->redraw();
}
void DeRotatorUI::cb_DisplayCameraAngleInput(Fl_Float_Input* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_DisplayCameraAngleInput_i(o,v);
}

void DeRotatorUI::cb_OK4_i(Fl_Button*, void*) {
  derotator_graphics->SetDisplayCameraAngle(atof(DisplayCameraAngleInput->value()));

SetDisplayCameraAnglePopup->hide();
derotator_graphics->redraw();
}
void DeRotatorUI::cb_OK4(Fl_Button* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_OK4_i(o,v);
}

void DeRotatorUI::cb_Cancel4_i(Fl_Button*, void*) {
  SetDisplayCameraAnglePopup->hide();
}
void DeRotatorUI::cb_Cancel4(Fl_Button* o, void* v) {
  ((DeRotatorUI*)(o->parent()->user_data()))->cb_Cancel4_i(o,v);
}

DeRotatorUI::DeRotatorUI() {
  { mainWindow = new Fl_Double_Window(398, 478, "Field DeRotator");
    mainWindow->box(FL_UP_BOX);
    mainWindow->callback((Fl_Callback*)cb_mainWindow, (void*)(this));
    { Fl_Group* o = new Fl_Group(5, 25, 385, 75, "Settings");
      o->box(FL_ENGRAVED_BOX);
      o->labeltype(FL_NO_LABEL);
      { Send = new Fl_Button(10, 30, 70, 64, "Send");
        Send->box(FL_PLASTIC_UP_BOX);
        Send->down_box(FL_PLASTIC_DOWN_BOX);
        Send->callback((Fl_Callback*)cb_Send);
      } // Fl_Button* Send
      { SetHome = new Fl_Light_Button(83, 30, 70, 64, "Set\nHome");
        SetHome->box(FL_PLASTIC_UP_BOX);
        SetHome->down_box(FL_PLASTIC_DOWN_BOX);
        SetHome->selection_color((Fl_Color)4);
        SetHome->labelsize(11);
        SetHome->callback((Fl_Callback*)cb_SetHome);
      } // Fl_Light_Button* SetHome
      { SetCWLimit = new Fl_Light_Button(156, 30, 70, 64, "Set\nCW\nLimit");
        SetCWLimit->box(FL_PLASTIC_UP_BOX);
        SetCWLimit->down_box(FL_PLASTIC_DOWN_BOX);
        SetCWLimit->selection_color((Fl_Color)4);
        SetCWLimit->labelsize(11);
        SetCWLimit->callback((Fl_Callback*)cb_SetCWLimit, (void*)(this));
      } // Fl_Light_Button* SetCWLimit
      { SetCCWLimit = new Fl_Light_Button(229, 30, 70, 64, "Set\nCCW\nLimit");
        SetCCWLimit->box(FL_PLASTIC_UP_BOX);
        SetCCWLimit->down_box(FL_PLASTIC_DOWN_BOX);
        SetCCWLimit->selection_color((Fl_Color)4);
        SetCCWLimit->labelsize(11);
        SetCCWLimit->callback((Fl_Callback*)cb_SetCCWLimit);
      } // Fl_Light_Button* SetCCWLimit
      { steps = new Fl_Int_Input(305, 33, 40, 22, "steps");
        steps->box(FL_DOWN_BOX);
        steps->color(FL_BACKGROUND2_COLOR);
        steps->selection_color(FL_SELECTION_COLOR);
        steps->labeltype(FL_NORMAL_LABEL);
        steps->labelfont(0);
        steps->labelsize(12);
        steps->labelcolor(FL_FOREGROUND_COLOR);
        steps->textsize(12);
        steps->callback((Fl_Callback*)cb_steps);
        steps->align(Fl_Align(FL_ALIGN_RIGHT));
        steps->when(FL_WHEN_ENTER_KEY);
      } // Fl_Int_Input* steps
      { deg = new Fl_Float_Input(305, 68, 40, 22, "deg");
        deg->box(FL_DOWN_BOX);
        deg->color(FL_BACKGROUND2_COLOR);
        deg->selection_color(FL_SELECTION_COLOR);
        deg->labeltype(FL_NORMAL_LABEL);
        deg->labelfont(0);
        deg->labelsize(12);
        deg->labelcolor(FL_FOREGROUND_COLOR);
        deg->textsize(12);
        deg->callback((Fl_Callback*)cb_deg);
        deg->align(Fl_Align(FL_ALIGN_RIGHT));
        deg->when(FL_WHEN_ENTER_KEY_ALWAYS);
      } // Fl_Float_Input* deg
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(5, 380, 385, 95, "Control");
      o->box(FL_ENGRAVED_BOX);
      o->labeltype(FL_NO_LABEL);
      { Start = new Fl_Button(10, 396, 64, 64, "Start @>");
        Start->box(FL_PLASTIC_UP_BOX);
        Start->down_box(FL_PLASTIC_DOWN_BOX);
        Start->callback((Fl_Callback*)cb_Start);
      } // Fl_Button* Start
      { Stop = new Fl_Button(80, 396, 64, 64, "Stop @||");
        Stop->box(FL_PLASTIC_UP_BOX);
        Stop->down_box(FL_PLASTIC_DOWN_BOX);
        Stop->labelcolor((Fl_Color)1);
        Stop->callback((Fl_Callback*)cb_Stop);
      } // Fl_Button* Stop
      { Home = new Fl_Button(150, 396, 64, 64, "Home @menu");
        Home->box(FL_PLASTIC_UP_BOX);
        Home->down_box(FL_PLASTIC_DOWN_BOX);
        Home->callback((Fl_Callback*)cb_Home);
      } // Fl_Button* Home
      { Messages = new Fl_Text_Display(220, 410, 160, 50, "Messages");
        _message_buffer = new Fl_Text_Buffer();
        Messages->buffer(_message_buffer); Messages->textsize(10);
        Messages->scrollbar_width(Messages->scrollbar_width()/2);
      } // Fl_Text_Display* Messages
      o->end();
    } // Fl_Group* o
    { MenuBar = new Fl_Menu_Bar(0, 0, 448, 20, "MenuBar");
      MenuBar->menu(menu_MenuBar);
    } // Fl_Menu_Bar* MenuBar
    { Graphics = new Fl_Group(5, 104, 385, 271, "Graphics");
      Graphics->box(FL_ENGRAVED_FRAME);
      Graphics->labeltype(FL_NO_LABEL);
      { derotator_graphics = new DeRotatorGraphics(5, 107, 385, 268, "GraphicsBox");
        derotator_graphics->box(FL_NO_BOX);
        derotator_graphics->color(FL_BACKGROUND_COLOR);
        derotator_graphics->selection_color(FL_BACKGROUND_COLOR);
        derotator_graphics->labeltype(FL_NORMAL_LABEL);
        derotator_graphics->labelfont(0);
        derotator_graphics->labelsize(14);
        derotator_graphics->labelcolor(FL_FOREGROUND_COLOR);
        derotator_graphics->align(Fl_Align(FL_ALIGN_CENTER));
        derotator_graphics->when(FL_WHEN_RELEASE);
      } // DeRotatorGraphics* derotator_graphics
      Graphics->end();
    } // Fl_Group* Graphics
    mainWindow->end();
  } // Fl_Double_Window* mainWindow
  { WifiIPPopup = new Fl_Double_Window(300, 84, "Wifi IP Address");
    WifiIPPopup->user_data((void*)(this));
    { IPAddress = new Fl_Input(90, 16, 200, 24, "IP address: ");
    } // Fl_Input* IPAddress
    { Fl_Button* o = new Fl_Button(10, 50, 63, 20, "OK");
      o->callback((Fl_Callback*)cb_OK);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(80, 50, 63, 20, "Cancel");
      o->callback((Fl_Callback*)cb_Cancel);
    } // Fl_Button* o
    WifiIPPopup->set_modal();
    WifiIPPopup->end();
  } // Fl_Double_Window* WifiIPPopup
  { SerialDevPopup = new Fl_Double_Window(300, 84, "Serial Device Name");
    SerialDevPopup->user_data((void*)(this));
    { SerialDevice = new Fl_Input(100, 16, 190, 24, "Serial device: ");
    } // Fl_Input* SerialDevice
    { Fl_Button* o = new Fl_Button(10, 50, 63, 20, "OK");
      o->callback((Fl_Callback*)cb_OK1);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(80, 50, 63, 20, "Cancel");
      o->callback((Fl_Callback*)cb_Cancel1);
    } // Fl_Button* o
    SerialDevPopup->set_modal();
    SerialDevPopup->end();
  } // Fl_Double_Window* SerialDevPopup
  { Fl_Double_Window* o = HardwareWLANPopup = new Fl_Double_Window(390, 172, "Hardware WLAN setup");
    HardwareWLANPopup->user_data((void*)(this));
    { Fl_Box* o = new Fl_Box(180, 10, 30, 16, "Setup can only be sent via Serial line");
      o->labelcolor((Fl_Color)1);
    } // Fl_Box* o
    { WLANSSID = new Fl_Input(80, 35, 230, 24, "SSID:");
    } // Fl_Input* WLANSSID
    { WLANPassword = new Fl_Input(80, 60, 230, 24, "Password:");
    } // Fl_Input* WLANPassword
    { WLANSecurity = new Fl_Choice(80, 85, 230, 24, "Security:");
      WLANSecurity->down_box(FL_BORDER_BOX);
      WLANSecurity->menu(menu_WLANSecurity);
    } // Fl_Choice* WLANSecurity
    { Fl_Button* o = new Fl_Button(95, 120, 120, 25, "Send via Serial");
      o->callback((Fl_Callback*)cb_Send1);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(220, 120, 64, 25, "Cancel");
      o->callback((Fl_Callback*)cb_Cancel2);
    } // Fl_Button* o
    o->position(4,200);
    HardwareWLANPopup->end();
  } // Fl_Double_Window* HardwareWLANPopup
  { Version = new Fl_Double_Window(255, 158, "Version");
    Version->user_data((void*)(this));
    { VersionLabel = new Fl_Box(25, 16, 204, 126, "DeRotator\nby\n C.Y. Tan\nVersion 1.00");
    } // Fl_Box* VersionLabel
    Version->set_modal();
    Version->end();
  } // Fl_Double_Window* Version
  { Fl_Double_Window* o = ConnectWithPopup = new Fl_Double_Window(226, 133, "Connect Window");
    ConnectWithPopup->user_data((void*)(this));
    { ConnectGroup = new Fl_Group(25, 25, 170, 60);
      { SerialPortSelected = new Fl_Round_Button(25, 25, 63, 15, "Serial port");
        SerialPortSelected->type(102);
        SerialPortSelected->down_box(FL_ROUND_DOWN_BOX);
      } // Fl_Round_Button* SerialPortSelected
      { WifiSelected = new Fl_Round_Button(25, 40, 63, 15, "Wifi");
        WifiSelected->type(102);
        WifiSelected->down_box(FL_ROUND_DOWN_BOX);
      } // Fl_Round_Button* WifiSelected
      { Fl_Round_Button* o = NoneSelected = new Fl_Round_Button(25, 55, 63, 15, "None (for debugging)");
        NoneSelected->type(102);
        NoneSelected->down_box(FL_ROUND_DOWN_BOX);
        o->setonly();
      } // Fl_Round_Button* NoneSelected
      ConnectGroup->end();
    } // Fl_Group* ConnectGroup
    { Fl_Button* o = new Fl_Button(81, 95, 63, 20, "OK");
      o->callback((Fl_Callback*)cb_OK2);
    } // Fl_Button* o
    o->position(80, 200);
    ConnectWithPopup->end();
  } // Fl_Double_Window* ConnectWithPopup
  { SetHallHomePopup = new Fl_Double_Window(300, 84, "Hall angle");
    SetHallHomePopup->user_data((void*)(this));
    { HallAngleInput = new Fl_Float_Input(205, 17, 55, 23, "Hall angle w.r.t. vertical (deg) : ");
      HallAngleInput->type(1);
      HallAngleInput->callback((Fl_Callback*)cb_HallAngleInput);
      HallAngleInput->when(FL_WHEN_ENTER_KEY);
    } // Fl_Float_Input* HallAngleInput
    { Fl_Button* o = new Fl_Button(10, 50, 63, 20, "OK");
      o->callback((Fl_Callback*)cb_OK3);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(80, 50, 63, 20, "Cancel");
      o->callback((Fl_Callback*)cb_Cancel3);
    } // Fl_Button* o
    SetHallHomePopup->set_modal();
    SetHallHomePopup->end();
  } // Fl_Double_Window* SetHallHomePopup
  { SetDisplayCameraAnglePopup = new Fl_Double_Window(300, 84, "Display camera angle");
    SetDisplayCameraAnglePopup->user_data((void*)(this));
    { DisplayCameraAngleInput = new Fl_Float_Input(215, 27, 55, 23, "Hall angle w.r.t. vertical (deg) : ");
      DisplayCameraAngleInput->type(1);
      DisplayCameraAngleInput->callback((Fl_Callback*)cb_DisplayCameraAngleInput);
      DisplayCameraAngleInput->when(FL_WHEN_ENTER_KEY);
    } // Fl_Float_Input* DisplayCameraAngleInput
    { Fl_Button* o = new Fl_Button(20, 60, 63, 20, "OK");
      o->callback((Fl_Callback*)cb_OK4);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(90, 60, 63, 20, "Cancel");
      o->callback((Fl_Callback*)cb_Cancel4);
    } // Fl_Button* o
    SetDisplayCameraAnglePopup->end();
  } // Fl_Double_Window* SetDisplayCameraAnglePopup
  // initialization code
  _serial_client = NULL;
  _tcp_client = NULL;
  
  /*
    For some stupid reason, if I initialize _*_help in its extra code, 
    the OpenGL graphcs doesn't show up.
    If I do it here, everything is ok. So I'm doing it here ...
  */
  
  _introduction = new Fl_Help_Dialog;
  _interface_help = new Fl_Help_Dialog;
  _controller_help = new Fl_Help_Dialog;
  
  /*
    Set up help directory depending on whether the help directory is found
  */
  using namespace boost::filesystem;
  path p("help");
  if(exists(p)){
    _help_dir = "help/";
  }
  else {
  // check if this is a Mac app bundle
  #ifdef __APPLE__
    char help_str[] = "help";
    unsigned short uhelp_str[64];
    for(int i=0; i<strlen(help_str); i++){
      uhelp_str[i] = help_str[i];
    }
    
    CFStringRef s = CFStringCreateWithCharacters(NULL, uhelp_str, strlen(help_str));
    CFURLRef appUrlRef;
    appUrlRef = CFBundleCopyResourceURL(CFBundleGetMainBundle(), s, NULL, NULL);
  
    CFStringRef filePathRef = CFURLCopyPath(appUrlRef);
    const char* filePath = CFStringGetCStringPtr(filePathRef, kCFStringEncodingUTF8);
  
    path p1(filePath);
    if(exists(p1)){
      _help_dir = filePath;
      CFRelease(filePathRef);
      CFRelease(appUrlRef);
    }
    else {
       // still set _help_dir to "help" even if it doesn't exist for now
      _help_dir = "help/";
      
      CFRelease(filePathRef);
      CFRelease(appUrlRef);	
    }
        
  #endif
  }
  
  
  /*
     _message_buffer must be initialized in Messages extra code because
     Messages buffer has to be initialized when Messages is created.
     Putting _message_buffer creation here causes a segmentaion fault.
  */
  
  // configuration object
  _derotator_config = new DeRotatorConfig(this);
  
  // read in global config on start up
  _derotator_config->Load();
}

void DeRotatorUI::show(int argc, char** argv) {
  mainWindow->show(argc, argv);
  
  //mainWindow->do_callback();
  ConnectWithPopup->position(mainWindow->x_root()+80, mainWindow->y_root()+200);
  ConnectWithPopup->show();
}

void DeRotatorUI::show() {
  mainWindow->show();
  //mainWindow->do_callback();
  ConnectWithPopup->position(mainWindow->x_root()+80, mainWindow->y_root()+200);
  ConnectWithPopup->show();
}

void DeRotatorUI::timer_cb(void* data) {
  // get the (alt, az, accumulated angle)
  using namespace std;
  using namespace logging::trivial;
  src::severity_logger< severity_level > lg;   
  
  DeRotatorUI* dr = (DeRotatorUI*)data;
  
  RequestPacket rq;
  rq._command = CMD_GET_ALTAZ_ZETA;
  
  ReplyPacket rp;
  int status;
  
  if((status=dr->SendCommand(&rq, &rp)) == REPLY_OK){
  #ifdef AAAAA
    LOG_TRACE << "alt = " << rp._fvalue[0] << " "
              << "az = " << rp._fvalue[1] << " "
              << "zeta = " << rp._fvalue[2] << " "
              << "angle (FA) = " << HA2FA(rp._fvalue[3]);
  #endif
    double home_angle = dr->derotator_graphics->GetHomeAngle();
    
    dr->derotator_graphics->ZAngle(rp._fvalue[2]);
    dr->derotator_graphics->ZOutlineAngle(HA2FA(rp._fvalue[3]) + home_angle);
    dr->derotator_graphics->ZCameraAngle(HA2FA(rp._fvalue[3]) + home_angle);
    dr->derotator_graphics->redraw();
   
    char buf[32];
    sprintf(buf, "%4.2f", HA2FA(rp._fvalue[3]));
    dr->deg->value(buf);
    
    sprintf(buf, "%4d", static_cast<int>(HA2FS(rp._fvalue[3])));
    dr->steps->value(buf);
  
  }
  else {
    switch(status){
      case REPLY_DEROTATOR_STEPSIZE_ERR:
        LOG_ERROR << "DeRotatorUI::timer_cb(): SendCommand(): step size too small";
        return;
      case REPLY_DEROTATOR_LIMITS_REACHED:
        LOG_ERROR << "DeRotatorUI::timer_cb(): SendCommand(): limits reached";
        return;
      case -1: 
        // lost the connection so disconnect wifi or serial line
        // and reactivate buttons
  
        if(dr->_tcp_client){
          // close the tcp port
          delete dr->_tcp_client;
          dr->_tcp_client = NULL;
          dr->WifiStatus->clear();
         }
  
         if(dr->_serial_client){
           delete dr->_serial_client;
  	 dr->_serial_client = NULL;
  	 dr->SerialStatus->clear();	   
         }
         dr->MenuBar->redraw(); // update the radio button status
         
         // reactive buttons	 
         dr->Start->activate();
         dr->Home->activate();
  
         dr->Send->activate();;
         dr->SetHome->activate();
         dr->SetCWLimit->activate();
         dr->SetCCWLimit->activate();    
      }
             
    LOG_ERROR << "DeRotatorUI::timer_cb(): SendCommand() failed";
    return;
  }
  
        
  Fl::repeat_timeout(REPEAT_TIME, timer_cb, data);
}

void DeRotatorUI::timer_cb1(void* data) {
  // get the angle of the derotator w.r.t. user home
  using namespace std;
  
  DeRotatorUI* dr = (DeRotatorUI*)data;
  
  RequestPacket rq;
  rq._command = CMD_GET_THETA;
  
  ReplyPacket rp;
  
  if(dr->SendCommand(&rq, &rp) == REPLY_OK){
  #ifdef AAAAAA
    cerr << "goto home: theta (FA) = " << HA2FA(rp._fvalue[0]) << "\n";
  #endif 
    double home_angle = dr->derotator_graphics->GetHomeAngle();
    double angle = HA2FA(rp._fvalue[0]) + home_angle; // returned angle already is w.r.t. home, so add it to get absolute angle
    dr->derotator_graphics->ZOutlineAngle(angle);
    dr->derotator_graphics->ZCameraAngle(angle);
    dr->derotator_graphics->redraw();
     
    char buf[32];
    sprintf(buf, "%4.2f", HA2FA(rp._fvalue[0]));
    dr->deg->value(buf);
    
    sprintf(buf, "%4d", static_cast<int>(HA2FS(rp._fvalue[0])));
    dr->steps->value(buf);
  
  }
  else {
    using namespace logging::trivial;
    src::severity_logger< severity_level > lg;          
    LOG_ERROR << "DeRotatorUI::timer_cb1(): SendCommand() failed!";
    return;
  }
  
  if(fabs(rp._fvalue[0]) > 0){      
    Fl::repeat_timeout(REPEAT_TIME, timer_cb1, data);
  }
  else {
    // and reactivate the buttons that were greyed out
    dr->Send->activate();
    dr->SetHome->activate();
    dr->SetCWLimit->activate();
    dr->SetCCWLimit->activate();
    dr->Start->activate();
   
    Fl::remove_timeout(timer_cb1, data);
  }
}

void DeRotatorUI::timer_cb2(void* data) {
  // get the angle of the derotator w.r.t. user home and stop when it is equal to the user wanted angle
  using namespace std;
  
  DeRotatorUI* dr = (DeRotatorUI*)data;
  
  RequestPacket rq;
  rq._command = CMD_GET_THETA;
  
  
  double home_angle = dr->derotator_graphics->GetHomeAngle();
  
  ReplyPacket rp;
  
  if(dr->SendCommand(&rq, &rp) == REPLY_OK){
  #ifdef AAAAAA
    cerr << "got angle: theta = " << HA2FA(rp._fvalue[0]) << " ";
    cerr << dr->derotator_graphics->ZOutlineAngle() << "\n";
  #endif  
    double angle = HA2FA(rp._fvalue[0]) + home_angle; // convert to absolute angle
    
    dr->derotator_graphics->ZCameraAngle(angle);
    dr->derotator_graphics->redraw();
   
    char buf[32];
    sprintf(buf, "%4.2f", HA2FA(rp._fvalue[0]));
    dr->deg->value(buf);
    
    sprintf(buf, "%4d", static_cast<int>(HA2FS(rp._fvalue[0])));
    dr->steps->value(buf);
  
  }
  else {
    using namespace logging::trivial;
    src::severity_logger< severity_level > lg;          
    LOG_ERROR << "DeRotatorUI::timer_cb2(): SendCommand() failed!";
    return;
  }
  
  // only continue the callback if we haven't reached the user angle
  double outline_angle = dr->derotator_graphics->ZOutlineAngle();
  const double EPS = MECHANICAL_STEPSIZE; // this is the angle size of each stepper step
  
  if(fabs(HA2FA(rp._fvalue[0])+home_angle - outline_angle) > EPS ){      
    Fl::repeat_timeout(REPEAT_TIME, timer_cb2, data);
  }
  else{
    Fl::remove_timeout(timer_cb2, data);
    // and reactivate the buttons that were greyed out
    dr->Start->activate();
    dr->Home->activate();
    dr->SetHome->activate();
    dr->SetCWLimit->activate();
    dr->SetCCWLimit->activate();
  }
}

int DeRotatorUI::SendCommand(RequestPacket* const rq) {
  // send the given command to the derotator
  using namespace std;
  
  try{
    if(_serial_client){
      if(_serial_client->Send(rq) != 0){
  	throw string("Serial: Send request failed");
      }
    }
    
    if(_tcp_client){
      if(_tcp_client->Send(rq) != 0){
        throw string("TCP: Send request failed");
      }
    }
    
    ReplyPacket rp;
    if(_serial_client){
      if(_serial_client->Receive(&rp) !=0){
        throw string("Serial: Did not receive reply packet");
      }
    }
    
    if(_tcp_client){
      if(_tcp_client->Receive(&rp) !=0){
        throw string("TCP: Did not receive reply packet");
      }
    }
    
    
    if(rp._reply != REPLY_OK){
      // throw string("Reply is not ok")
      using namespace logging::trivial;
      src::severity_logger< severity_level > lg;          
      LOG_ERROR << "Reply is not ok";
      LOG_ERROR << "Got reply = " << rp._reply;
    }
  
    return rp._reply;    
  }
  catch(string& message){
    using namespace logging::trivial;
    src::severity_logger< severity_level > lg; 
    LOG_ERROR << "DeRotatorUI::SendCommand(): "
              << message;
    return -1;    
  }
}

int DeRotatorUI::SendCommand(RequestPacket* const rq, ReplyPacket* const rp) {
  // send the given command and receive the reply
  // from the derotator
  using namespace std;
  
  try{
      
    if(_serial_client){
      if(_serial_client->Send(rq) != 0){
        throw string("Serial: Send request failed");
      }
    }
    
    if(_tcp_client){
      if(_tcp_client->Send(rq) != 0){
        throw string("TCP: Send request failed");
      }
    }
    
    
    if(_serial_client){
      if(_serial_client->Receive(rp) !=0){
        throw string("Serial: Did not receive reply packet");
      }
    }
    
    if(_tcp_client){
      if(_tcp_client->Receive(rp) !=0){
        throw string("TCP: Did not receive reply packet");
      }
    }
    
    
    if(rp->_reply != REPLY_OK){
      using namespace logging::trivial;
      src::severity_logger< severity_level > lg;          
      // throw string("Reply is not ok");
      LOG_ERROR << "Reply is not ok";
      LOG_ERROR << "Got reply = " << rp->_reply;
    }
    
    return rp->_reply;
  }
  catch(string& message){
    using namespace logging::trivial;
    src::severity_logger< severity_level > lg; 
    LOG_ERROR << "DeRotatorUI::SendCommand(): "
              << message;
    return -1;    
  }
}
